## Algorithm With Python 算法的python实现

[TOC]

### 1.Stack 栈

#### 介绍

栈允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

#### 基本功能

| 功能                     | 描述                            |
| ------------------------ | ------------------------------- |
| init                     | 新建list，设定长度极限limit     |
| push进栈                 | 未超limit，加入list, Ot(1)      |
| pop出栈                  | 栈若非空弹出顶部元素pop(),Ot(1) |
| peek查看堆栈顶部元素     | 若非空，返回list[-1]            |
| is_empty判断栈是否为空： | return not bool(self.stack)     |
| size栈的大小：           | return len(self.stack)          |

#### 应用

| 功能                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| balanced_parentheses() | 1_001有效括号字符串：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 |
| class MinStack         | 1_002 最小栈(LeerCode 115)                                   |

### 2.linked_list 列表

#### 介绍

链表(linked_list)是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

#### 基本功能

| 功能                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| Node.init                     | self.data = data             self.next = None                |
| Linked_List.init              | self.head = head                                             |
| append(new_element)           | 向链表添加新的结点                                           |
| is_empty()                    | 判断链表是否为空                                             |
| insert(position, new_element) | 往链表中任意位置添加一个 new_element 元素。<br/>先判断要插入的位置是否在链表的索引范围内。 <br/>当插入的位置是头结点（即索引为 0）时，做特殊情况处理。<br/> 当要插入结点的位置不在 0 时，找到要插入的位置，插入新结点 |
| remove(position)              | 从链表中任意位置删除一个元素。<br/>先判断要删除的元素索引是否存在，如果不存在抛出错误<br/>接着判断当存在链表元素时才能执行删除操作。<br/>当要删除的是头结点时（即索引为 0），做特殊情况处理。<br/>其他情况时，通过循环找到要删除的结点。<br/>最后要做的就是把这个结点删除掉。 |
| get_length                    | 获取链表的长度                                               |
| print_list                    | 遍历链表，并将元素依次打印出来                               |
| reverse                       | 将链表反转                                                   |
| initlist(data_list)           | 将列表转换为链表                                             |
|                               |                                                              |

#### 应用

| 功能           | 描述                   |
| -------------- | ---------------------- |
| swapNodes(a,b) | 2-001交换2个阶段的位置 |

### 3.Double_linked_list 双链表

#### 介绍

双向链表（Double_linked_list）也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。

#### 基本功能

| 功能              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| Node.init         | self.data = data             self.next = None      self.prev = None |
| DLinked_List.init | self.head = head      #head =None                            |
| is_empty()        | 判断链表是否为空                                             |
| travel()          | 遍历列表                                                     |
| add(item)         | 头部插入元素                                                 |
| append(item)      | 尾部插入元素                                                 |
| search(item)      | 查找元素是否存在                                             |
| insert(pos, item) | 在指定位置添加节点                                           |
| remove(item)      | 删除元素                                                     |
|                   |                                                              |

### 4.queue 队列

#### 介绍

队列 (queue) 是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列有两种实现形式，分为两种：**数组**和**链表**。

#### 基本功能

| 功能              | 描述                                          |
| ----------------- | --------------------------------------------- |
| Node.init         | self.data = data             self.next = None |
| DLinked_List.init | self.head = head      self.rear = None        |
| is_empty()        | 判断队列是否为空                              |
| enqueue(elem)     | 入队                                          |
| dequeue()         | 出队                                          |
| peek()            | 返回队头部元素                                |
| print_queue()     | 打印队列                                      |

### 5.tree 树

树 (tree) 是一种非常高效的非线性存储结构。树，可以很形象的理解，有根，有叶子，对应在数据结构中就是根节点、叶子节点，同一层的叶子叫兄弟节点，邻近不同层的叫父子节点，非常好理解。

其他概念解释

- **二叉树**，就是每个节点都至多有二个子节点的树。
- **满二叉树**，就是除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。
- **完全二叉树**，就是叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。

#### 基本功能

| 功能             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| Node.init        | self.item = item             self.left = None  # 表示左子节点         self.right = None  # 表示右子节点 |
| Tree.init        | self.root = Node('root')                                     |
| add(item)        | 添加子节点到树里面                                           |
| get_parent(item) | 找到 item 的父节点                                           |
| delete(item)     | 从二叉树中删除一个子节点*                                    |
| inorder(node)    | 中序遍历                                                     |
| postorder(node)  | 后续遍历                                                     |
| preorder(node)   | 先续遍历                                                     |

*删除二叉树

```shell
先获取待删除节点 item 的父节点（以下简称 item）。
    如果父节点不为空，判断 item 的左右子树是否存在：
        当左子树为空时，进一步判断 item 是父节点的左孩子，还是右孩子；
            如果是左孩子，将父节点的左指针指向 item 的右子树，反之将父节点的右指针指向 item 的右子树。
        当右子树为空时，进一步判断 item 是父节点的左孩子，还是右孩子；
            如果是左孩子，将父节点的左指针指向 item 的左子树，反之将父节点的右指针指向 item 的左子树。
        当左右子树均不为空时，寻找右子树中的最左叶子节点 x，将 x 替代要删除的节点。
    删除成功，返回 True。
    删除失败, 返回 False。
```

#### 应用

| 功能                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| sortedArrayToBST(list) | 5-001[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)(leet-code108) |
| maxDepth(root)         | 5-002二叉树的最大深度(leet-code104)                          |

### 6.TrieNode字典树

字典树，又称单词查找树，Trie  树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

#### 字典树的主要性质

它有 3 个基本性质：

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符；
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；
3. 每个节点的所有子节点包含的字符都不相同。

#### 基本功能

| 功能               | 描述                                                |
| ------------------ | --------------------------------------------------- |
| TrieNode.init      | self.nodes = dict()            self.is_leaf = False |
| insert(word)       | 插入一个字到字典树中                                |
| insert_many(words) | 插入一列表的字到字典树中（循环insert()）            |
| search(word)       | 在字典树里面查询一个字                              |

### 7.heap 堆

堆 (heap) 是一种经过排序的完全二叉树，其中任一非叶子节点的值均不大于（或不小于）其左孩子和右孩子节点的值。

其他概念解释

- **最大堆** 根结点的键值是所有堆结点键值中最大者。
- **最小堆** 根结点的键值是所有堆结点键值中最小者。

#### 基本功能

| 功能                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| heap.init                | self.data_list = []                                          |
| get_parent_index( index) | 返回父节点的下标，使用二进制位移>>                           |
| swap( index_a, index_b)  | 交换数组中的两个元素                                         |
| insert(data)             | 插入元素并堆化# 先把元素放在最后，然后从后往前依次堆化，以大顶堆为例，如果插入元素比父节点大，则交换，直到最后 |
| removeMax()              | 删除堆顶元素，然后将最后一个元素放在堆顶，再从上往下依次堆化 |
| heapify(index)           | 从上往下堆化，从index 开始堆化操作 (大顶堆)==@.@==           |

### 8.Graph 图

- **无向图** 图是若干个顶点(Vertices)和边(Edges)相互连接组成的。边仅由两个顶点连接，并且没有方向的图称为无向图。

- **有向图** 在有向图中，边是单向的：每条边连接的两个顶点都是一个有序对，它们的邻接性是单向的。我们开发过程中碰到的很多场景都是有向图：比如任务调度的依赖关系，社交网络的任务关系等等都是天然的有向图。

- **度** 一个顶点的度是指与该顶点相关联的边的条数，顶点 v 的度记作 d(v)。

  表示图通常有四种方法：数组表示法、邻接表、十字链表和邻接多重表。邻接表是图的一种链式存储结构，十字链表是有向图的另一种链式存储结构，邻接多重表是无向图的另一种链式存储结构。

  #### 基本功能

  **待添加**

### 9.并查集

待添加







### 哈希            

### 哈希表            

### 混沌机            

### 数学上几个基本问题            

### 斐波那契数列问题            

### 线性代数

资源：[沉浸式线性代数](http://immersivemath.com/ila/index.html)。[麻省理工公开课:线性代数_全三集](http://open.163.com/special/opencourse/daishu.html)。[3Blue1Brown](https://space.bilibili.com/88461692?from=search&seid=9898388095015449432)。孟岩的《理解矩阵》    

- **标量** 一个标量就是一个单独的数，一般用小写的变量名称表示。
- **向量** 一个向量就是一列数，这些数是有序排列的。用过次序中的索引，我们可以确定每个单独的数。通常会赋予向量粗体的小写名称。
- **矩阵** 一个矩阵是二维数组，其中的每一个元素被两个索引而非一个所确定。我们通常会赋予矩阵粗体的大写变量名称，比如 A。
- **张量** 几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们将其称之为张量。使用粗体 A 来表示张量“A”

   

### 常见的排序算法介绍            

### 正则表达式的使用            

### 数论基础            

### 双重哈希            

### 摘要算法            

### 算术分析方法            

### 最大公约数问题            

### 常见的搜索算法介绍            

### 字符串的基本概念            

### 常见的字符串处理算法            