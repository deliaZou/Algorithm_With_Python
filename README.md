## Algorithm With Python 算法的python实现

[TOC]

### Stack 栈

#### 介绍

栈允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

#### 基本功能

| 功能                     | 描述                            |
| ------------------------ | ------------------------------- |
| init                     | 新建list，设定长度极限limit     |
| push进栈                 | 未超limit，加入list, Ot(1)      |
| pop出栈                  | 栈若非空弹出顶部元素pop(),Ot(1) |
| peek查看堆栈顶部元素     | 若非空，返回list[-1]            |
| is_empty判断栈是否为空： | return not bool(self.stack)     |
| size栈的大小：           | return len(self.stack)          |

#### 应用

| 功能                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| balanced_parentheses() | 1_001有效括号字符串：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 |
|                        |                                                              |

### linked_list 列表

#### 介绍

链表(linked_list)是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

#### 基本功能

| 功能                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| Node.init                     | self.data = data             self.next = None                |
| Linked_List.init              | self.head = head                                             |
| append(new_element)           | 向链表添加新的结点                                           |
| is_empty()                    | 判断链表是否为空                                             |
| insert(position, new_element) | 往链表中任意位置添加一个 new_element 元素。<br/>先判断要插入的位置是否在链表的索引范围内。 <br/>当插入的位置是头结点（即索引为 0）时，做特殊情况处理。<br/> 当要插入结点的位置不在 0 时，找到要插入的位置，插入新结点 |
| remove(position)              | 从链表中任意位置删除一个元素。<br/>先判断要删除的元素索引是否存在，如果不存在抛出错误<br/>接着判断当存在链表元素时才能执行删除操作。<br/>当要删除的是头结点时（即索引为 0），做特殊情况处理。<br/>其他情况时，通过循环找到要删除的结点。<br/>最后要做的就是把这个结点删除掉。 |
| get_length                    | 获取链表的长度                                               |
| print_list                    | 遍历链表，并将元素依次打印出来                               |
| reverse                       | 将链表反转                                                   |
| initlist(data_list)           | 将列表转换为链表                                             |
|                               |                                                              |

#### 应用

| 功能           | 描述                   |
| -------------- | ---------------------- |
| swapNodes(a,b) | 2-001交换2个阶段的位置 |

### Double_linked_list 双链表

#### 介绍

双向链表（Double_linked_list）也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。

#### 基本功能

| 功能              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| Node.init         | self.data = data             self.next = None      self.prev = None |
| DLinked_List.init | self.head = head      #head =None                            |
| is_empty()        | 判断链表是否为空                                             |
| travel()          | 遍历列表                                                     |
| add(item)         | 头部插入元素                                                 |
| append(item)      | 尾部插入元素                                                 |
| search(item)      | 查找元素是否存在                                             |
| insert(pos, item) | 在指定位置添加节点                                           |
| remove(item)      | 删除元素                                                     |
|                   |                                                              |

### queue 队列

#### 介绍

队列 (queue) 是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列有两种实现形式，分为两种：**数组**和**链表**。

#### 基本功能

| 功能              | 描述                                          |
| ----------------- | --------------------------------------------- |
| Node.init         | self.data = data             self.next = None |
| DLinked_List.init | self.head = head      self.rear = None        |
| is_empty()        | 判断队列是否为空                              |
| enqueue(elem)     | 入队                                          |
| dequeue()         | 出队                                          |
| peek()            | 返回队头部元素                                |
| print_queue()     | 打印队列                                      |

### tree 树

树 (tree) 是一种非常高效的非线性存储结构。树，可以很形象的理解，有根，有叶子，对应在数据结构中就是根节点、叶子节点，同一层的叶子叫兄弟节点，邻近不同层的叫父子节点，非常好理解。

其他概念解释

- **二叉树**，就是每个节点都至多有二个子节点的树。
- **满二叉树**，就是除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。
- **完全二叉树**，就是叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。

#### 基本功能

| 功能             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| Node.init        | self.item = item             self.left = None  # 表示左子节点         self.right = None  # 表示右子节点 |
| Tree.init        | self.root = Node('root')                                     |
| add(item)        | 添加子节点到树里面                                           |
| get_parent(item) | 找到 item 的父节点                                           |
| delete(item)     | 从二叉树中删除一个子节点*                                    |
| inorder(node)    | 中序遍历                                                     |
| print_queue()    | 打印队列                                                     |
| postorder(node)  | 后续遍历                                                     |
| preorder(node)   | 先续遍历                                                     |

*删除二叉树

```shell
先获取待删除节点 item 的父节点（以下简称 item）。
    如果父节点不为空，判断 item 的左右子树是否存在：
        当左子树为空时，进一步判断 item 是父节点的左孩子，还是右孩子；
            如果是左孩子，将父节点的左指针指向 item 的右子树，反之将父节点的右指针指向 item 的右子树。
        当右子树为空时，进一步判断 item 是父节点的左孩子，还是右孩子；
            如果是左孩子，将父节点的左指针指向 item 的左子树，反之将父节点的右指针指向 item 的左子树。
        当左右子树均不为空时，寻找右子树中的最左叶子节点 x，将 x 替代要删除的节点。
    删除成功，返回 True。
    删除失败, 返回 False。
```